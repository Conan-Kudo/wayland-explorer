{"type":"protocol","name":"ext_session_lock_v1","copyright":{"type":"copyright","text":"Copyright 2021 Isaac Freund\n\n    Permission to use, copy, modify, and/or distribute this software for any\n    purpose with or without fee is hereby granted, provided that the above\n    copyright notice and this permission notice appear in all copies.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE."},"description":{"type":"description","text":"This protocol allows for a privileged Wayland client to lock the session\n    and display arbitrary graphics while the session is locked.\n\n    The compositor may choose to restrict this protocol to a special client\n    launched by the compositor itself or expose it to all privileged clients,\n    this is compositor policy.\n\n    The client is responsible for performing authentication and informing the\n    compositor when the session should be unlocked. If the client dies while\n    the session is locked the session remains locked, possibly permanently\n    depending on compositor policy.\n\n    Warning! The protocol described in this file is currently in the\n    testing phase. Backward compatible changes may be added together with\n    the corresponding interface version bump. Backward incompatible changes\n    can only be done by creating a new major version of the extension.","summary":"secure session locking with arbitrary graphics"},"interfaces":[{"type":"interface","name":"ext_session_lock_manager_v1","version":"1","description":{"type":"description","text":"This interface is used to request that the session be locked.","summary":"used to lock the session"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"This informs the compositor that the session lock manager object will\n        no longer be used. Existing objects created through this interface\n        remain valid.","summary":"destroy the session lock manager object"},"args":[]},{"type":"request","name":"lock","description":{"type":"description","text":"This request creates a session lock and asks the compositor to lock the\n        session. The compositor will send either the ext_session_lock_v1.locked\n        or ext_session_lock_v1.finished event on the created object in\n        response to this request.","summary":"attempt to lock the session"},"args":[{"type":"arg","name":"id","argType":"new_id","interface":"ext_session_lock_v1"}]}],"events":[],"enums":[]},{"type":"interface","name":"ext_session_lock_v1","version":"1","description":{"type":"description","text":"On creation of this object either the locked or finished event will\n      immediately be sent.\n\n      The locked event indicates that the session is locked. This means that\n      the compositor should stop rendering and providing input to normal\n      clients. Instead the compositor should blank all outputs with an opaque\n      color such that their normal content is fully hidden.\n\n      The only surfaces that should be rendered while the session is locked\n      are the lock surfaces created through this interface and optionally,\n      at the compositor's discretion, special privileged surfaces such as\n      input methods or portions of desktop shell UIs.\n\n      If the client dies while the session is locked, the compositor should not\n      unlock the session in response. It is acceptable for the session to be\n      permanently locked if this happens. The compositor may choose to continue\n      to display the lock surfaces the client had mapped before it died or\n      alternatively fall back to a solid color, this is compositor policy.\n\n      Compositors may also allow a secure way to recover the session, the\n      details of this are compositor policy. Compositors may allow a new\n      client to create a ext_session_lock_v1 object and take responsibility\n      for unlocking the session, they may even start a new lock client\n      instance automatically.","summary":"manage lock state and create lock surfaces"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"This informs the compositor that the lock object will no longer be\n        used. Existing objects created through this interface remain valid.\n\n        After this request is made, lock surfaces created through this object\n        should be destroyed by the client as they will no longer be used by\n        the compositor.\n\n        It is a protocol error to make this request if the locked event was\n        sent, the unlock_and_destroy request must be used instead.","summary":"destroy the session lock"},"args":[]},{"type":"request","name":"get_lock_surface","description":{"type":"description","text":"The client is expected to create lock surfaces for all outputs\n        currently present and any new outputs as they are advertised. These\n        won't be displayed by the compositor unless the lock is successful\n        and the locked event is sent.\n\n        Providing a wl_surface which already has a role or already has a buffer\n        attached or committed is a protocol error, as is attaching/committing\n        a buffer before the first ext_session_lock_surface_v1.configure event.\n\n        Attempting to create more than one lock surface for a given output\n        is a duplicate_output protocol error.","summary":"create a lock surface for a given output"},"args":[{"type":"arg","name":"id","argType":"new_id","interface":"ext_session_lock_surface_v1"},{"type":"arg","name":"surface","argType":"object","interface":"wl_surface"},{"type":"arg","name":"output","argType":"object","interface":"wl_output"}]},{"type":"request","name":"unlock_and_destroy","requestType":"destructor","description":{"type":"description","text":"This request indicates that the session should be unlocked, for\n        example because the user has entered their password and it has been\n        verified by the client.\n\n        This request also informs the compositor that the lock object will\n        no longer be used and may be safely destroyed. Existing objects\n        created through this interface remain valid.\n\n        After this request is made, lock surfaces created through this object\n        should be destroyed by the client as they will no longer be used by\n        the compositor.\n\n        It is a protocol error to make this request if the locked event has\n        not been sent. In that case, the lock object may only be destroyed\n        using the destroy request.\n        \n        Note that a correct client that wishes to exit directly after unlocking\n        the session must use the wl_display.sync request to ensure the server\n        receives and processes the unlock_and_destroy request. Otherwise\n        there is no guarantee that the server has unlocked the session due\n        to the asynchronous nature of the Wayland protocol. For example,\n        the server might terminate the client with a protocol error before\n        it processes the unlock_and_destroy request.","summary":"unlock the session, destroying the object"},"args":[]}],"events":[{"type":"event","name":"locked","description":{"type":"description","text":"This client is now responsible for displaying graphics while the\n        session is locked and deciding when to unlock the session.\n\n        Either this event or the finished event will be sent immediately on\n        creation of this object.\n\n        If this event is sent, making the destroy request is a protocol error,\n        the lock object may only be destroyed using the unlock_and_destroy\n        request.","summary":"session successfully locked"},"args":[]},{"type":"event","name":"finished","description":{"type":"description","text":"The compositor has decided that the session lock should be\n        destroyed. Exactly when this event is sent is compositor policy, but\n        it will never be sent more than once for a given session lock object.\n\n        This might be sent because there is already another ext_session_lock_v1\n        object held by a client, or the compositor has decided to deny the\n        request to lock the session for some other reason. This might also\n        be sent because the compositor implements some alternative, secure\n        way to authenticate and unlock the session.\n\n        Either this event or the locked event will be sent exactly once on\n        creation of this object. If the locked event is sent on creation of\n        this object, the finished event may still be sent at some later time\n        in this object's lifetime, this is compositor policy.\n\n        Upon receiving this event, the client should make either the destroy\n        request or the unlock_and_destroy request, depending on whether or\n        not the locked event was received on this object.","summary":"the session lock object should be destroyed"},"args":[]}],"enums":[{"type":"enum","name":"error","bitfield":false,"entries":[{"type":"entry","name":"invalid_destroy","value":"0","summary":"attempted to destroy session lock while locked"},{"type":"entry","name":"invalid_unlock","value":"1","summary":"unlock requested but locked event was never sent"},{"type":"entry","name":"role","value":"2","summary":"given wl_surface already has a role"},{"type":"entry","name":"duplicate_output","value":"3","summary":"given output already has a lock surface"},{"type":"entry","name":"already_constructed","value":"4","summary":"given wl_surface has a buffer attached or committed"}]}]},{"type":"interface","name":"ext_session_lock_surface_v1","version":"1","description":{"type":"description","text":"The client may use lock surfaces to display a screensaver, render a\n      dialog to enter a password and unlock the session, or however else it\n      sees fit.\n\n      On binding this interface the compositor will immediately send the\n      first configure event. After making the ack_configure request in\n      response to this event the client may attach and commit the first\n      buffer. Committing the surface before acking the first configure is a\n      protocol error. Committing the surface with a null buffer at any time\n      is a protocol error.\n\n      The compositor is free to handle keyboard/pointer focus for lock\n      surfaces however it chooses. A reasonable way to do this would be to\n      give the first lock surface created keyboard focus and change keyboard\n      focus if the user clicks on other surfaces.","summary":"a surface displayed while the session is locked"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"This informs the compositor that the lock surface object will no\n        longer be used.\n\n        It is recommended for a lock client to destroy lock surfaces if\n        their corresponding wl_output global is removed.\n\n        If a lock surface on an active output is destroyed before the\n        ext_session_lock_v1.unlock_and_destroy event is sent, the compositor\n        must fall back to rendering a solid color.","summary":"destroy the lock surface object"},"args":[]},{"type":"request","name":"ack_configure","description":{"type":"description","text":"When a configure event is received, if a client commits the surface\n        in response to the configure event, then the client must make an\n        ack_configure request sometime before the commit request, passing\n        along the serial of the configure event.\n\n        If the client receives multiple configure events before it can\n        respond to one, it only has to ack the last configure event.\n\n        A client is not required to commit immediately after sending an\n        ack_configure request - it may even ack_configure several times\n        before its next surface commit.\n\n        A client may send multiple ack_configure requests before committing,\n        but only the last request sent before a commit indicates which\n        configure event the client really is responding to.\n\n        Sending an ack_configure request consumes the configure event\n        referenced by the given serial, as well as all older configure events\n        sent on this object.\n\n        It is a protocol error to issue multiple ack_configure requests\n        referencing the same configure event or to issue an ack_configure\n        request referencing a configure event older than the last configure\n        event acked for a given lock surface.","summary":"ack a configure event"},"args":[{"type":"arg","name":"serial","argType":"uint","summary":"serial from the configure event"}]}],"events":[{"type":"event","name":"configure","description":{"type":"description","text":"This event is sent once on binding the interface and may be sent again\n        at the compositor's discretion, for example if output geometry changes.\n\n        The width and height are in surface-local coordinates and are exact\n        requirements. Failing to match these surface dimensions in the next\n        commit after acking a configure is a protocol error.","summary":"the client should resize its surface"},"args":[{"type":"arg","name":"serial","argType":"uint","summary":"serial for use in ack_configure"},{"type":"arg","name":"width","argType":"uint"},{"type":"arg","name":"height","argType":"uint"}]}],"enums":[{"type":"enum","name":"error","bitfield":false,"entries":[{"type":"entry","name":"commit_before_first_ack","value":"0","summary":"surface committed before first ack_configure request"},{"type":"entry","name":"null_buffer","value":"1","summary":"surface committed with a null buffer"},{"type":"entry","name":"dimensions_mismatch","value":"2","summary":"failed to match ack'd width/height"},{"type":"entry","name":"invalid_serial","value":"3","summary":"serial provided in ack_configure is invalid"}]}]}]}