{"type":"protocol","name":"agl_shell","copyright":{"type":"copyright","text":"Copyright Â© 2019, 2022 Collabora, Ltd.\n\n    Permission is hereby granted, free of charge, to any person obtaining a\n    copy of this software and associated documentation files (the \"Software\"),\n    to deal in the Software without restriction, including without limitation\n    the rights to use, copy, modify, merge, publish, distribute, sublicense,\n    and/or sell copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice (including the next\n    paragraph) shall be included in all copies or substantial portions of the\n    Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE."},"interfaces":[{"type":"interface","name":"agl_shell","version":"7","description":{"type":"description","text":"Starting with version 2 of the protocol, the client is required to wait\n      for the 'bound_ok' or 'bound_fail' events in order to proceed further.\n\n      In case the client gets a 'bound_fail' event then it should consider that\n      there's another client already bound to the agl_shell protocol.\n      A client that receives a 'bound_ok' event should consider that there's\n      no other client already bound to the interface and can proceed further.\n\n      If the client uses an older version of the protocol it will receive\n      automatically an error and the compositor will terminate the connection,\n      if there's another client already bound the interface.\n\n      If the client receives the 'bound_fail' event and attempts to use the\n      interface further it will receive an error and the compositor will\n      terminate the connection. After the 'bound_fail' event was received the\n      client should call the destructor, which has been added with version 2\n      of the protocol. The client is free to try at a later point in time to\n      see if it will receive the 'bound_ok' event, but there's no explicit way\n      of finding out when that event will be delivered.\n      It is assumed that it can infer that information through other\n      means/other channels.","summary":"user interface for Automotive Grade Linux platform"},"requests":[{"type":"request","name":"ready","description":{"type":"description","text":"Tell the server that this client is ready to be shown. The server\n        will delay presentation during start-up until all shell clients are\n        ready to be shown, and will display a black screen instead.\n        This gives the client an opportunity to set up and configure several\n        surfaces into a coherent interface.\n\n        The client that binds to this interface must send this request, otherwise\n        they may stall the compositor unnecessarily.\n\n        If this request is called after the compositor has already finished\n        start-up, no operation is performed.","summary":"client is ready to be shown"},"args":[]},{"type":"request","name":"set_background","description":{"type":"description","text":"Set the surface to act as the background of an output. After this\n        request, the server will immediately send a configure event with\n        the dimensions the client should use to cover the entire output.\n\n        The surface must have a \"desktop\" surface role, as supported by\n        libweston-desktop.\n\n        Only a single surface may be the background for any output. If a\n        background surface already exists, a protocol error is raised.","summary":"set surface as output's background"},"args":[{"type":"arg","name":"surface","argType":"object","interface":"wl_surface"},{"type":"arg","name":"output","argType":"object","interface":"wl_output"}]},{"type":"request","name":"set_panel","description":{"type":"description","text":"Set the surface to act as a panel of an output. The 'edge' argument\n        says what edge of the output the surface will be anchored to.\n        After this request, the server will send a configure event with the\n        corresponding width/height that the client should use, and 0 for the\n        other dimension. E.g. if the edge is 'top', the width will be the\n        output's width, and the height will be 0.\n\n        The surface must have a \"desktop\" surface role, as supported by\n        libweston-desktop.\n\n        The compositor will take the panel's window geometry into account when\n        positioning other windows, so the panels are not covered.\n\n        XXX: What happens if e.g. both top and left are used at the same time?\n        Who gets to have the corner?\n\n        Only a single surface may be the panel for an output's edge. If a\n        surface already exists on an edge, a protocol error is raised.","summary":"set surface as panel"},"args":[{"type":"arg","name":"surface","argType":"object","interface":"wl_surface"},{"type":"arg","name":"output","argType":"object","interface":"wl_output"},{"type":"arg","name":"edge","argType":"uint","enum":"edge"}]},{"type":"request","name":"activate_app","description":{"type":"description","text":"Ask the compositor to make a toplevel to become the current/focused\n        window for window management purposes.\n\n        See xdg_toplevel.set_app_id from the xdg-shell protocol for a\n        description of app_id.\n\n        If multiple toplevels have the same app_id, the result is unspecified.\n\n        XXX: Do we need feedback to say it didn't work? (e.g. client does\n        not exist)","summary":"make client current window"},"args":[{"type":"arg","name":"app_id","argType":"string"},{"type":"arg","name":"output","argType":"object","interface":"wl_output"}]},{"type":"request","name":"destroy","requestType":"destructor","since":"2","description":{"type":"description","summary":"destroys the factory object"},"args":[]},{"type":"request","name":"set_activate_region","since":"4","description":{"type":"description","text":"A hint for the compositor to use a custom area, rather than\n      inferring the activation area. If any panels are used\n      the compositor computes the activation area by subtracting the\n      panels geometry area. If no panels are used then the entire output\n      is being used. This request changes that as to hint the compositor\n      to use the supplied rectangle and ignore any potential panels\n      that might been set-up previously.\n\n      In order for this request to take effect it will need to happen\n      before the 'ready' request in order for the compositor to make use of it.\n      Note that any 'set_panel' request be will not be honored, if this request\n      has been called.\n\n      The x and y coordinates use the top-left corner as the origin. The\n      rectangle area shouldn't exceed the output area, while an area smaller\n      than the output, would basically result in showing up the background\n      surface.","summary":"sets a specific region to activate"},"args":[{"type":"arg","name":"output","argType":"object","interface":"wl_output"},{"type":"arg","name":"x","argType":"int","summary":"x position of rectangle"},{"type":"arg","name":"y","argType":"int","summary":"y position of rectangle"},{"type":"arg","name":"width","argType":"int","summary":"width of rectangle"},{"type":"arg","name":"height","argType":"int","summary":"height of rectangle"}]},{"type":"request","name":"deactivate_app","since":"5","description":{"type":"description","text":"Ask the compositor to hide the toplevel window for window\n        management purposes. Depending on the window role, this request\n        will either display the previously active window (or the background\n        in case there's no previously active surface) or temporarily (or\n        until a 'activate_app' is called upon) hide the surface.\n\n        All the surfaces are identifiable by using the app_id, and no actions\n        are taken in case the app_id is not/was not present.\n\n        See xdg_toplevel.set_app_id from the xdg-shell protocol for a\n        description of app_id.","summary":"de-activate/hide window identified by app_id"},"args":[{"type":"arg","name":"app_id","argType":"string"}]},{"type":"request","name":"set_app_float","since":"6","description":{"type":"description","text":"Makes the application identified by app_id as floating. If the\n        application's window is already mapped, in a maximized, normal state,\n        it would transition to the float state.\n\n        For applications that want to modify their own state, this request\n        must be done before the initial surface commit in order to take effect.\n\n        If the application is already in floating state, this request wouldn't\n        do anything.\n\n        There's no persistence of this request, once the application terminated\n        you'll to issue this request again for that particular app_id.\n\n        The x, and y values would be initial position of the window where the\n        window surface will be placed.\n\n        See xdg_toplevel.set_app_id from the xdg-shell protocol for a\n        description of app_id.","summary":"set the window identified by app_id as float"},"args":[{"type":"arg","name":"app_id","argType":"string"},{"type":"arg","name":"x","argType":"int","summary":"x position"},{"type":"arg","name":"y","argType":"int","summary":"y position"}]},{"type":"request","name":"set_app_normal","since":"6","description":{"type":"description","text":"Returns the application identified by app_id as it was in the normal state.\n      This is useful to come back from other states to the maximized state, the\n      normal state applications are started.","summary":"set the window identified by app_id as normally started"},"args":[{"type":"arg","name":"app_id","argType":"string"}]},{"type":"request","name":"set_app_fullscreen","since":"7","description":{"type":"description","text":"Makes the application identified by app_id as fullscreen. If the\n        application's window is already mapped, in a maximized, normal state,\n        it would transition to the fullscreen state.\n\n        For applications that want to modify their own state, this request\n        must be done before the initial surface commit in order to take effect.\n\n        If the application is already in fullscreen state, this request wouldn't\n        do anything.\n\n        There's no persistence of this request, once the application terminated\n        you'll to issue this request again for that particular app_id.\n\n        See xdg_toplevel.set_app_id from the xdg-shell protocol for a\n        description of app_id.","summary":""},"args":[{"type":"arg","name":"app_id","argType":"string"}]}],"events":[{"type":"event","name":"bound_ok","since":"2","description":{"type":"description","text":"Informs the client that it was able to bind the agl_shell\n        interface succesfully. Clients are required to wait for this\n        event before continuing further.","summary":"event sent if binding was ok"},"args":[]},{"type":"event","name":"bound_fail","since":"2","description":{"type":"description","text":"Informs the client that binding to the agl_shell interface was\n        unsuccesfull. Clients are required to wait for this event for\n        continuing further.","summary":"event sent if binding was nok"},"args":[]},{"type":"event","name":"app_state","since":"3","description":{"type":"description","text":"Informs the client that an application has changed its state to another,\n        specified by the app_state enum. Client can use this event to track\n        current application state. For instance to know when the application has\n        started, or when terminated/stopped.","summary":"event sent when an application suffered state modification"},"args":[{"type":"arg","name":"app_id","argType":"string"},{"type":"arg","name":"state","argType":"uint","enum":"app_state"}]}],"enums":[{"type":"enum","name":"error","bitfield":false,"entries":[{"type":"entry","name":"invalid_argument","value":"0"},{"type":"entry","name":"background_exists","value":"1"},{"type":"entry","name":"panel_exists","value":"2"}]},{"type":"enum","name":"edge","bitfield":false,"entries":[{"type":"entry","name":"top","value":"0"},{"type":"entry","name":"bottom","value":"1"},{"type":"entry","name":"left","value":"2"},{"type":"entry","name":"right","value":"3"}]},{"type":"enum","name":"app_state","since":"3","bitfield":false,"entries":[{"type":"entry","name":"started","value":"0"},{"type":"entry","name":"terminated","value":"1"},{"type":"entry","name":"activated","value":"2"},{"type":"entry","name":"deactivated","value":"3"}]}]},{"type":"interface","name":"agl_shell_ext","version":"1","description":{"type":"description","text":"This interface allows another client bind to the agl_shell interface,\n      while there's another shell client already present.\n\n      The client should first bind to this interface and then inform the\n      compositor with the 'doas_shell_client' request and it wants to bind to\n      the agl_shell interface. The client is still expected, if using a new\n      version of the agl_shell interface, to wait for the 'bound_ok' and\n      'bound_fail' events before issueing any other requests/events.\n\n      Note that this interface has its limitations, and the compositor would\n      still refuse the act for 'set_panel' or 'set_background' requests\n      of the agl_shell interface if there's already a client that used them.\n\n      Any other requests or events should be delievered and handled as it would\n      a client bound to the agl_shell interface.","summary":"extended user interface for Automotive Grade Linux platform"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"Call the destructor once you're ready with agl_shell_ext interface.\n        This would reset the state and would make any requests made\n        on the agl_shell interface be terminated. The client would need \n        to bind again the agl_shell_ext and issue a 'doas_shell_client'\n        request.","summary":"destroys the factory object"},"args":[]},{"type":"request","name":"doas_shell_client","description":{"type":"description","text":"Prior to binding to agl_shell interface, this request would inform\n        the compositor that it wants to gain access the agl_shell interface.\n        The client is expected to wait for 'doas_shell_client_done' event and \n        check for a successful status before going further with binding to\n        the agl_shell interface.","summary":"Informs the compositor it wants to bind to the\n      agl_shell interface"},"args":[]}],"events":[{"type":"event","name":"doas_done","description":{"type":"description","text":"The client should check the status event to verify that the\n        compositor was able to handle the request.","summary":"event sent as a reply to doas_shell_client"},"args":[{"type":"arg","name":"status","argType":"uint","enum":"doas_shell_client_status"}]}],"enums":[{"type":"enum","name":"doas_shell_client_status","bitfield":false,"entries":[{"type":"entry","name":"success","value":"0"},{"type":"entry","name":"failed","value":"1"}]}]}]}