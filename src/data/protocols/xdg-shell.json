{"type":"protocol","name":"xdg_shell","copyright":{"type":"copyright","text":"Copyright © 2008-2013 Kristian Høgsberg\n    Copyright © 2013      Rafael Antognolli\n    Copyright © 2013      Jasper St. Pierre\n    Copyright © 2010-2013 Intel Corporation\n    Copyright © 2015-2017 Samsung Electronics Co., Ltd\n    Copyright © 2015-2017 Red Hat Inc.\n\n    Permission is hereby granted, free of charge, to any person obtaining a\n    copy of this software and associated documentation files (the \"Software\"),\n    to deal in the Software without restriction, including without limitation\n    the rights to use, copy, modify, merge, publish, distribute, sublicense,\n    and/or sell copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice (including the next\n    paragraph) shall be included in all copies or substantial portions of the\n    Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE."},"interfaces":[{"type":"interface","name":"xdg_wm_base","version":"6","description":{"type":"description","text":"The xdg_wm_base interface is exposed as a global object enabling clients\n      to turn their wl_surfaces into windows in a desktop environment. It\n      defines the basic functionality needed for clients and the compositor to\n      create windows that can be dragged, resized, maximized, etc, as well as\n      creating transient windows such as popup menus.","summary":"create desktop-style surfaces"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"Destroy this xdg_wm_base object.\n\n\tDestroying a bound xdg_wm_base object while there are surfaces\n\tstill alive created by this xdg_wm_base object instance is illegal\n\tand will result in a defunct_surfaces error.","summary":"destroy xdg_wm_base"},"args":[]},{"type":"request","name":"create_positioner","description":{"type":"description","text":"Create a positioner object. A positioner object is used to position\n\tsurfaces relative to some parent surface. See the interface description\n\tand xdg_surface.get_popup for details.","summary":"create a positioner object"},"args":[{"type":"arg","name":"id","argType":"new_id","interface":"xdg_positioner"}]},{"type":"request","name":"get_xdg_surface","description":{"type":"description","text":"This creates an xdg_surface for the given surface. While xdg_surface\n\titself is not a role, the corresponding surface may only be assigned\n\ta role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is\n\tillegal to create an xdg_surface for a wl_surface which already has an\n\tassigned role and this will result in a role error.\n\n\tThis creates an xdg_surface for the given surface. An xdg_surface is\n\tused as basis to define a role to a given surface, such as xdg_toplevel\n\tor xdg_popup. It also manages functionality shared between xdg_surface\n\tbased surface roles.\n\n\tSee the documentation of xdg_surface for more details about what an\n\txdg_surface is and how it is used.","summary":"create a shell surface from a surface"},"args":[{"type":"arg","name":"id","argType":"new_id","interface":"xdg_surface"},{"type":"arg","name":"surface","argType":"object","interface":"wl_surface"}]},{"type":"request","name":"pong","description":{"type":"description","text":"A client must respond to a ping event with a pong request or\n\tthe client may be deemed unresponsive. See xdg_wm_base.ping\n\tand xdg_wm_base.error.unresponsive.","summary":"respond to a ping event"},"args":[{"type":"arg","name":"serial","argType":"uint","summary":"serial of the ping event"}]}],"events":[{"type":"event","name":"ping","description":{"type":"description","text":"The ping event asks the client if it's still alive. Pass the\n\tserial specified in the event back to the compositor by sending\n\ta \"pong\" request back with the specified serial. See xdg_wm_base.pong.\n\n\tCompositors can use this to determine if the client is still\n\talive. It's unspecified what will happen if the client doesn't\n\trespond to the ping request, or in what timeframe. Clients should\n\ttry to respond in a reasonable amount of time. The “unresponsive”\n\terror is provided for compositors that wish to disconnect unresponsive\n\tclients.\n\n\tA compositor is free to ping in any way it wants, but a client must\n\talways respond to any xdg_wm_base object it created.","summary":"check if the client is alive"},"args":[{"type":"arg","name":"serial","argType":"uint","summary":"pass this to the pong request"}]}],"enums":[{"type":"enum","name":"error","bitfield":false,"entries":[{"type":"entry","name":"role","value":"0","summary":"given wl_surface has another role"},{"type":"entry","name":"defunct_surfaces","value":"1","summary":"xdg_wm_base was destroyed before children"},{"type":"entry","name":"not_the_topmost_popup","value":"2","summary":"the client tried to map or destroy a non-topmost popup"},{"type":"entry","name":"invalid_popup_parent","value":"3","summary":"the client specified an invalid popup parent surface"},{"type":"entry","name":"invalid_surface_state","value":"4","summary":"the client provided an invalid surface state"},{"type":"entry","name":"invalid_positioner","value":"5","summary":"the client provided an invalid positioner"},{"type":"entry","name":"unresponsive","value":"6","summary":"the client didn’t respond to a ping event in time"}]}]},{"type":"interface","name":"xdg_positioner","version":"6","description":{"type":"description","text":"The xdg_positioner provides a collection of rules for the placement of a\n      child surface relative to a parent surface. Rules can be defined to ensure\n      the child surface remains within the visible area's borders, and to\n      specify how the child surface changes its position, such as sliding along\n      an axis, or flipping around a rectangle. These positioner-created rules are\n      constrained by the requirement that a child surface must intersect with or\n      be at least partially adjacent to its parent surface.\n\n      See the various requests for details about possible rules.\n\n      At the time of the request, the compositor makes a copy of the rules\n      specified by the xdg_positioner. Thus, after the request is complete the\n      xdg_positioner object can be destroyed or reused; further changes to the\n      object will have no effect on previous usages.\n\n      For an xdg_positioner object to be considered complete, it must have a\n      non-zero size set by set_size, and a non-zero anchor rectangle set by\n      set_anchor_rect. Passing an incomplete xdg_positioner object when\n      positioning a surface raises an invalid_positioner error.","summary":"child surface positioner"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"Notify the compositor that the xdg_positioner will no longer be used.","summary":"destroy the xdg_positioner object"},"args":[]},{"type":"request","name":"set_size","description":{"type":"description","text":"Set the size of the surface that is to be positioned with the positioner\n\tobject. The size is in surface-local coordinates and corresponds to the\n\twindow geometry. See xdg_surface.set_window_geometry.\n\n\tIf a zero or negative size is set the invalid_input error is raised.","summary":"set the size of the to-be positioned rectangle"},"args":[{"type":"arg","name":"width","argType":"int","summary":"width of positioned rectangle"},{"type":"arg","name":"height","argType":"int","summary":"height of positioned rectangle"}]},{"type":"request","name":"set_anchor_rect","description":{"type":"description","text":"Specify the anchor rectangle within the parent surface that the child\n\tsurface will be placed relative to. The rectangle is relative to the\n\twindow geometry as defined by xdg_surface.set_window_geometry of the\n\tparent surface.\n\n\tWhen the xdg_positioner object is used to position a child surface, the\n\tanchor rectangle may not extend outside the window geometry of the\n\tpositioned child's parent surface.\n\n\tIf a negative size is set the invalid_input error is raised.","summary":"set the anchor rectangle within the parent surface"},"args":[{"type":"arg","name":"x","argType":"int","summary":"x position of anchor rectangle"},{"type":"arg","name":"y","argType":"int","summary":"y position of anchor rectangle"},{"type":"arg","name":"width","argType":"int","summary":"width of anchor rectangle"},{"type":"arg","name":"height","argType":"int","summary":"height of anchor rectangle"}]},{"type":"request","name":"set_anchor","description":{"type":"description","text":"Defines the anchor point for the anchor rectangle. The specified anchor\n\tis used derive an anchor point that the child surface will be\n\tpositioned relative to. If a corner anchor is set (e.g. 'top_left' or\n\t'bottom_right'), the anchor point will be at the specified corner;\n\totherwise, the derived anchor point will be centered on the specified\n\tedge, or in the center of the anchor rectangle if no edge is specified.","summary":"set anchor rectangle anchor"},"args":[{"type":"arg","name":"anchor","argType":"uint","summary":"anchor","enum":"anchor"}]},{"type":"request","name":"set_gravity","description":{"type":"description","text":"Defines in what direction a surface should be positioned, relative to\n\tthe anchor point of the parent surface. If a corner gravity is\n\tspecified (e.g. 'bottom_right' or 'top_left'), then the child surface\n\twill be placed towards the specified gravity; otherwise, the child\n\tsurface will be centered over the anchor point on any axis that had no\n\tgravity specified. If the gravity is not in the ‘gravity’ enum, an\n\tinvalid_input error is raised.","summary":"set child surface gravity"},"args":[{"type":"arg","name":"gravity","argType":"uint","summary":"gravity direction","enum":"gravity"}]},{"type":"request","name":"set_constraint_adjustment","description":{"type":"description","text":"Specify how the window should be positioned if the originally intended\n\tposition caused the surface to be constrained, meaning at least\n\tpartially outside positioning boundaries set by the compositor. The\n\tadjustment is set by constructing a bitmask describing the adjustment to\n\tbe made when the surface is constrained on that axis.\n\n\tIf no bit for one axis is set, the compositor will assume that the child\n\tsurface should not change its position on that axis when constrained.\n\n\tIf more than one bit for one axis is set, the order of how adjustments\n\tare applied is specified in the corresponding adjustment descriptions.\n\n\tThe default adjustment is none.","summary":"set the adjustment to be done when constrained"},"args":[{"type":"arg","name":"constraint_adjustment","argType":"uint","summary":"bit mask of constraint adjustments","enum":"constraint_adjustment"}]},{"type":"request","name":"set_offset","description":{"type":"description","text":"Specify the surface position offset relative to the position of the\n\tanchor on the anchor rectangle and the anchor on the surface. For\n\texample if the anchor of the anchor rectangle is at (x, y), the surface\n\thas the gravity bottom|right, and the offset is (ox, oy), the calculated\n\tsurface position will be (x + ox, y + oy). The offset position of the\n\tsurface is the one used for constraint testing. See\n\tset_constraint_adjustment.\n\n\tAn example use case is placing a popup menu on top of a user interface\n\telement, while aligning the user interface element of the parent surface\n\twith some user interface element placed somewhere in the popup surface.","summary":"set surface position offset"},"args":[{"type":"arg","name":"x","argType":"int","summary":"surface position x offset"},{"type":"arg","name":"y","argType":"int","summary":"surface position y offset"}]},{"type":"request","name":"set_reactive","since":"3","description":{"type":"description","text":"When set reactive, the surface is reconstrained if the conditions used\n\tfor constraining changed, e.g. the parent window moved.\n\n\tIf the conditions changed and the popup was reconstrained, an\n\txdg_popup.configure event is sent with updated geometry, followed by an\n\txdg_surface.configure event.","summary":"continuously reconstrain the surface"},"args":[]},{"type":"request","name":"set_parent_size","since":"3","description":{"type":"description","text":"Set the parent window geometry the compositor should use when\n\tpositioning the popup. The compositor may use this information to\n\tdetermine the future state the popup should be constrained using. If\n\tthis doesn't match the dimension of the parent the popup is eventually\n\tpositioned against, the behavior is undefined.\n\n\tThe arguments are given in the surface-local coordinate space.","summary":""},"args":[{"type":"arg","name":"parent_width","argType":"int","summary":"future window geometry width of parent"},{"type":"arg","name":"parent_height","argType":"int","summary":"future window geometry height of parent"}]},{"type":"request","name":"set_parent_configure","since":"3","description":{"type":"description","text":"Set the serial of an xdg_surface.configure event this positioner will be\n\tused in response to. The compositor may use this information together\n\twith set_parent_size to determine what future state the popup should be\n\tconstrained using.","summary":"set parent configure this is a response to"},"args":[{"type":"arg","name":"serial","argType":"uint","summary":"serial of parent configure event"}]}],"events":[],"enums":[{"type":"enum","name":"error","bitfield":false,"entries":[{"type":"entry","name":"invalid_input","value":"0","summary":"invalid input provided"}]},{"type":"enum","name":"anchor","bitfield":false,"entries":[{"type":"entry","name":"none","value":"0"},{"type":"entry","name":"top","value":"1"},{"type":"entry","name":"bottom","value":"2"},{"type":"entry","name":"left","value":"3"},{"type":"entry","name":"right","value":"4"},{"type":"entry","name":"top_left","value":"5"},{"type":"entry","name":"bottom_left","value":"6"},{"type":"entry","name":"top_right","value":"7"},{"type":"entry","name":"bottom_right","value":"8"}]},{"type":"enum","name":"gravity","bitfield":false,"entries":[{"type":"entry","name":"none","value":"0"},{"type":"entry","name":"top","value":"1"},{"type":"entry","name":"bottom","value":"2"},{"type":"entry","name":"left","value":"3"},{"type":"entry","name":"right","value":"4"},{"type":"entry","name":"top_left","value":"5"},{"type":"entry","name":"bottom_left","value":"6"},{"type":"entry","name":"top_right","value":"7"},{"type":"entry","name":"bottom_right","value":"8"}]},{"type":"enum","name":"constraint_adjustment","bitfield":true,"description":{"type":"description","text":"The constraint adjustment value define ways the compositor will adjust\n\tthe position of the surface, if the unadjusted position would result\n\tin the surface being partly constrained.\n\n\tWhether a surface is considered 'constrained' is left to the compositor\n\tto determine. For example, the surface may be partly outside the\n\tcompositor's defined 'work area', thus necessitating the child surface's\n\tposition be adjusted until it is entirely inside the work area.\n\n\tThe adjustments can be combined, according to a defined precedence: 1)\n\tFlip, 2) Slide, 3) Resize.","summary":"constraint adjustments"},"entries":[{"type":"entry","name":"none","value":"0","description":{"type":"description","text":"Don't alter the surface position even if it is constrained on some\n\t  axis, for example partially outside the edge of an output.","summary":"don't move the child surface when constrained"}},{"type":"entry","name":"slide_x","value":"1","description":{"type":"description","text":"Slide the surface along the x axis until it is no longer constrained.\n\n\t  First try to slide towards the direction of the gravity on the x axis\n\t  until either the edge in the opposite direction of the gravity is\n\t  unconstrained or the edge in the direction of the gravity is\n\t  constrained.\n\n\t  Then try to slide towards the opposite direction of the gravity on the\n\t  x axis until either the edge in the direction of the gravity is\n\t  unconstrained or the edge in the opposite direction of the gravity is\n\t  constrained.","summary":"move along the x axis until unconstrained"}},{"type":"entry","name":"slide_y","value":"2","description":{"type":"description","text":"Slide the surface along the y axis until it is no longer constrained.\n\n\t  First try to slide towards the direction of the gravity on the y axis\n\t  until either the edge in the opposite direction of the gravity is\n\t  unconstrained or the edge in the direction of the gravity is\n\t  constrained.\n\n\t  Then try to slide towards the opposite direction of the gravity on the\n\t  y axis until either the edge in the direction of the gravity is\n\t  unconstrained or the edge in the opposite direction of the gravity is\n\t  constrained.","summary":"move along the y axis until unconstrained"}},{"type":"entry","name":"flip_x","value":"4","description":{"type":"description","text":"Invert the anchor and gravity on the x axis if the surface is\n\t  constrained on the x axis. For example, if the left edge of the\n\t  surface is constrained, the gravity is 'left' and the anchor is\n\t  'left', change the gravity to 'right' and the anchor to 'right'.\n\n\t  If the adjusted position also ends up being constrained, the resulting\n\t  position of the flip_x adjustment will be the one before the\n\t  adjustment.","summary":"invert the anchor and gravity on the x axis"}},{"type":"entry","name":"flip_y","value":"8","description":{"type":"description","text":"Invert the anchor and gravity on the y axis if the surface is\n\t  constrained on the y axis. For example, if the bottom edge of the\n\t  surface is constrained, the gravity is 'bottom' and the anchor is\n\t  'bottom', change the gravity to 'top' and the anchor to 'top'.\n\n\t  The adjusted position is calculated given the original anchor\n\t  rectangle and offset, but with the new flipped anchor and gravity\n\t  values.\n\n\t  If the adjusted position also ends up being constrained, the resulting\n\t  position of the flip_y adjustment will be the one before the\n\t  adjustment.","summary":"invert the anchor and gravity on the y axis"}},{"type":"entry","name":"resize_x","value":"16","description":{"type":"description","text":"Resize the surface horizontally so that it is completely\n\t  unconstrained.","summary":"horizontally resize the surface"}},{"type":"entry","name":"resize_y","value":"32","description":{"type":"description","text":"Resize the surface vertically so that it is completely unconstrained.","summary":"vertically resize the surface"}}]}]},{"type":"interface","name":"xdg_surface","version":"6","description":{"type":"description","text":"An interface that may be implemented by a wl_surface, for\n      implementations that provide a desktop-style user interface.\n\n      It provides a base set of functionality required to construct user\n      interface elements requiring management by the compositor, such as\n      toplevel windows, menus, etc. The types of functionality are split into\n      xdg_surface roles.\n\n      Creating an xdg_surface does not set the role for a wl_surface. In order\n      to map an xdg_surface, the client must create a role-specific object\n      using, e.g., get_toplevel, get_popup. The wl_surface for any given\n      xdg_surface can have at most one role, and may not be assigned any role\n      not based on xdg_surface.\n\n      A role must be assigned before any other requests are made to the\n      xdg_surface object.\n\n      The client must call wl_surface.commit on the corresponding wl_surface\n      for the xdg_surface state to take effect.\n\n      Creating an xdg_surface from a wl_surface which has a buffer attached or\n      committed is a client error, and any attempts by a client to attach or\n      manipulate a buffer prior to the first xdg_surface.configure call must\n      also be treated as errors.\n\n      After creating a role-specific object and setting it up, the client must\n      perform an initial commit without any buffer attached. The compositor\n      will reply with initial wl_surface state such as\n      wl_surface.preferred_buffer_scale followed by an xdg_surface.configure\n      event. The client must acknowledge it and is then allowed to attach a\n      buffer to map the surface.\n\n      Mapping an xdg_surface-based role surface is defined as making it\n      possible for the surface to be shown by the compositor. Note that\n      a mapped surface is not guaranteed to be visible once it is mapped.\n\n      For an xdg_surface to be mapped by the compositor, the following\n      conditions must be met:\n      (1) the client has assigned an xdg_surface-based role to the surface\n      (2) the client has set and committed the xdg_surface state and the\n\t  role-dependent state to the surface\n      (3) the client has committed a buffer to the surface\n\n      A newly-unmapped surface is considered to have met condition (1) out\n      of the 3 required conditions for mapping a surface if its role surface\n      has not been destroyed, i.e. the client must perform the initial commit\n      again before attaching a buffer.","summary":"desktop user interface surface base interface"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"Destroy the xdg_surface object. An xdg_surface must only be destroyed\n\tafter its role object has been destroyed, otherwise\n\ta defunct_role_object error is raised.","summary":"destroy the xdg_surface"},"args":[]},{"type":"request","name":"get_toplevel","description":{"type":"description","text":"This creates an xdg_toplevel object for the given xdg_surface and gives\n\tthe associated wl_surface the xdg_toplevel role.\n\n\tSee the documentation of xdg_toplevel for more details about what an\n\txdg_toplevel is and how it is used.","summary":"assign the xdg_toplevel surface role"},"args":[{"type":"arg","name":"id","argType":"new_id","interface":"xdg_toplevel"}]},{"type":"request","name":"get_popup","description":{"type":"description","text":"This creates an xdg_popup object for the given xdg_surface and gives\n\tthe associated wl_surface the xdg_popup role.\n\n\tIf null is passed as a parent, a parent surface must be specified using\n\tsome other protocol, before committing the initial state.\n\n\tSee the documentation of xdg_popup for more details about what an\n\txdg_popup is and how it is used.","summary":"assign the xdg_popup surface role"},"args":[{"type":"arg","name":"id","argType":"new_id","interface":"xdg_popup"},{"type":"arg","name":"parent","argType":"object","interface":"xdg_surface","allowNull":"true"},{"type":"arg","name":"positioner","argType":"object","interface":"xdg_positioner"}]},{"type":"request","name":"set_window_geometry","description":{"type":"description","text":"The window geometry of a surface is its \"visible bounds\" from the\n\tuser's perspective. Client-side decorations often have invisible\n\tportions like drop-shadows which should be ignored for the\n\tpurposes of aligning, placing and constraining windows.\n\n\tThe window geometry is double-buffered state, see wl_surface.commit.\n\n\tWhen maintaining a position, the compositor should treat the (x, y)\n\tcoordinate of the window geometry as the top left corner of the window.\n\tA client changing the (x, y) window geometry coordinate should in\n\tgeneral not alter the position of the window.\n\n\tOnce the window geometry of the surface is set, it is not possible to\n\tunset it, and it will remain the same until set_window_geometry is\n\tcalled again, even if a new subsurface or buffer is attached.\n\n\tIf never set, the value is the full bounds of the surface,\n\tincluding any subsurfaces. This updates dynamically on every\n\tcommit. This unset is meant for extremely simple clients.\n\n\tThe arguments are given in the surface-local coordinate space of\n\tthe wl_surface associated with this xdg_surface, and may extend outside\n\tof the wl_surface itself to mark parts of the subsurface tree as part of\n\tthe window geometry.\n\n\tWhen applied, the effective window geometry will be the set window\n\tgeometry clamped to the bounding rectangle of the combined\n\tgeometry of the surface of the xdg_surface and the associated\n\tsubsurfaces.\n\n\tThe effective geometry will not be recalculated unless a new call to\n\tset_window_geometry is done and the new pending surface state is\n\tsubsequently applied.\n\n\tThe width and height of the effective window geometry must be\n\tgreater than zero. Setting an invalid size will raise an\n\tinvalid_size error.","summary":"set the new window geometry"},"args":[{"type":"arg","name":"x","argType":"int"},{"type":"arg","name":"y","argType":"int"},{"type":"arg","name":"width","argType":"int"},{"type":"arg","name":"height","argType":"int"}]},{"type":"request","name":"ack_configure","description":{"type":"description","text":"When a configure event is received, if a client commits the\n\tsurface in response to the configure event, then the client\n\tmust make an ack_configure request sometime before the commit\n\trequest, passing along the serial of the configure event.\n\n\tFor instance, for toplevel surfaces the compositor might use this\n\tinformation to move a surface to the top left only when the client has\n\tdrawn itself for the maximized or fullscreen state.\n\n\tIf the client receives multiple configure events before it\n\tcan respond to one, it only has to ack the last configure event.\n\tAcking a configure event that was never sent raises an invalid_serial\n\terror.\n\n\tA client is not required to commit immediately after sending\n\tan ack_configure request - it may even ack_configure several times\n\tbefore its next surface commit.\n\n\tA client may send multiple ack_configure requests before committing, but\n\tonly the last request sent before a commit indicates which configure\n\tevent the client really is responding to.\n\n\tSending an ack_configure request consumes the serial number sent with\n\tthe request, as well as serial numbers sent by all configure events\n\tsent on this xdg_surface prior to the configure event referenced by\n\tthe committed serial.\n\n\tIt is an error to issue multiple ack_configure requests referencing a\n\tserial from the same configure event, or to issue an ack_configure\n\trequest referencing a serial from a configure event issued before the\n\tevent identified by the last ack_configure request for the same\n\txdg_surface. Doing so will raise an invalid_serial error.","summary":"ack a configure event"},"args":[{"type":"arg","name":"serial","argType":"uint","summary":"the serial from the configure event"}]}],"events":[{"type":"event","name":"configure","description":{"type":"description","text":"The configure event marks the end of a configure sequence. A configure\n\tsequence is a set of one or more events configuring the state of the\n\txdg_surface, including the final xdg_surface.configure event.\n\n\tWhere applicable, xdg_surface surface roles will during a configure\n\tsequence extend this event as a latched state sent as events before the\n\txdg_surface.configure event. Such events should be considered to make up\n\ta set of atomically applied configuration states, where the\n\txdg_surface.configure commits the accumulated state.\n\n\tClients should arrange their surface for the new states, and then send\n\tan ack_configure request with the serial sent in this configure event at\n\tsome point before committing the new surface.\n\n\tIf the client receives multiple configure events before it can respond\n\tto one, it is free to discard all but the last event it received.","summary":"suggest a surface change"},"args":[{"type":"arg","name":"serial","argType":"uint","summary":"serial of the configure event"}]}],"enums":[{"type":"enum","name":"error","bitfield":false,"entries":[{"type":"entry","name":"not_constructed","value":"1","summary":"Surface was not fully constructed"},{"type":"entry","name":"already_constructed","value":"2","summary":"Surface was already constructed"},{"type":"entry","name":"unconfigured_buffer","value":"3","summary":"Attaching a buffer to an unconfigured surface"},{"type":"entry","name":"invalid_serial","value":"4","summary":"Invalid serial number when acking a configure event"},{"type":"entry","name":"invalid_size","value":"5","summary":"Width or height was zero or negative"},{"type":"entry","name":"defunct_role_object","value":"6","summary":"Surface was destroyed before its role object"}]}]},{"type":"interface","name":"xdg_toplevel","version":"6","description":{"type":"description","text":"This interface defines an xdg_surface role which allows a surface to,\n      among other things, set window-like properties such as maximize,\n      fullscreen, and minimize, set application-specific metadata like title and\n      id, and well as trigger user interactive operations such as interactive\n      resize and move.\n\n      A xdg_toplevel by default is responsible for providing the full intended\n      visual representation of the toplevel, which depending on the window\n      state, may mean things like a title bar, window controls and drop shadow.\n\n      Unmapping an xdg_toplevel means that the surface cannot be shown\n      by the compositor until it is explicitly mapped again.\n      All active operations (e.g., move, resize) are canceled and all\n      attributes (e.g. title, state, stacking, ...) are discarded for\n      an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to\n      the state it had right after xdg_surface.get_toplevel. The client\n      can re-map the toplevel by performing a commit without any buffer\n      attached, waiting for a configure event and handling it as usual (see\n      xdg_surface description).\n\n      Attaching a null buffer to a toplevel unmaps the surface.","summary":"toplevel surface"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"This request destroys the role surface and unmaps the surface;\n\tsee \"Unmapping\" behavior in interface section for details.","summary":"destroy the xdg_toplevel"},"args":[]},{"type":"request","name":"set_parent","description":{"type":"description","text":"Set the \"parent\" of this surface. This surface should be stacked\n\tabove the parent surface and all other ancestor surfaces.\n\n\tParent surfaces should be set on dialogs, toolboxes, or other\n\t\"auxiliary\" surfaces, so that the parent is raised when the dialog\n\tis raised.\n\n\tSetting a null parent for a child surface unsets its parent. Setting\n\ta null parent for a surface which currently has no parent is a no-op.\n\n\tOnly mapped surfaces can have child surfaces. Setting a parent which\n\tis not mapped is equivalent to setting a null parent. If a surface\n\tbecomes unmapped, its children's parent is set to the parent of\n\tthe now-unmapped surface. If the now-unmapped surface has no parent,\n\tits children's parent is unset. If the now-unmapped surface becomes\n\tmapped again, its parent-child relationship is not restored.\n\n\tThe parent toplevel must not be one of the child toplevel's\n\tdescendants, and the parent must be different from the child toplevel,\n\totherwise the invalid_parent protocol error is raised.","summary":"set the parent of this surface"},"args":[{"type":"arg","name":"parent","argType":"object","interface":"xdg_toplevel","allowNull":"true"}]},{"type":"request","name":"set_title","description":{"type":"description","text":"Set a short title for the surface.\n\n\tThis string may be used to identify the surface in a task bar,\n\twindow list, or other user interface elements provided by the\n\tcompositor.\n\n\tThe string must be encoded in UTF-8.","summary":"set surface title"},"args":[{"type":"arg","name":"title","argType":"string"}]},{"type":"request","name":"set_app_id","description":{"type":"description","text":"Set an application identifier for the surface.\n\n\tThe app ID identifies the general class of applications to which\n\tthe surface belongs. The compositor can use this to group multiple\n\tsurfaces together, or to determine how to launch a new application.\n\n\tFor D-Bus activatable applications, the app ID is used as the D-Bus\n\tservice name.\n\n\tThe compositor shell will try to group application surfaces together\n\tby their app ID. As a best practice, it is suggested to select app\n\tID's that match the basename of the application's .desktop file.\n\tFor example, \"org.freedesktop.FooViewer\" where the .desktop file is\n\t\"org.freedesktop.FooViewer.desktop\".\n\n\tLike other properties, a set_app_id request can be sent after the\n\txdg_toplevel has been mapped to update the property.\n\n\tSee the desktop-entry specification [0] for more details on\n\tapplication identifiers and how they relate to well-known D-Bus\n\tnames and .desktop files.\n\n\t[0] https://standards.freedesktop.org/desktop-entry-spec/","summary":"set application ID"},"args":[{"type":"arg","name":"app_id","argType":"string"}]},{"type":"request","name":"show_window_menu","description":{"type":"description","text":"Clients implementing client-side decorations might want to show\n\ta context menu when right-clicking on the decorations, giving the\n\tuser a menu that they can use to maximize or minimize the window.\n\n\tThis request asks the compositor to pop up such a window menu at\n\tthe given position, relative to the local surface coordinates of\n\tthe parent surface. There are no guarantees as to what menu items\n\tthe window menu contains, or even if a window menu will be drawn\n\tat all.\n\n\tThis request must be used in response to some sort of user action\n\tlike a button press, key press, or touch down event.","summary":"show the window menu"},"args":[{"type":"arg","name":"seat","argType":"object","summary":"the wl_seat of the user event","interface":"wl_seat"},{"type":"arg","name":"serial","argType":"uint","summary":"the serial of the user event"},{"type":"arg","name":"x","argType":"int","summary":"the x position to pop up the window menu at"},{"type":"arg","name":"y","argType":"int","summary":"the y position to pop up the window menu at"}]},{"type":"request","name":"move","description":{"type":"description","text":"Start an interactive, user-driven move of the surface.\n\n\tThis request must be used in response to some sort of user action\n\tlike a button press, key press, or touch down event. The passed\n\tserial is used to determine the type of interactive move (touch,\n\tpointer, etc).\n\n\tThe server may ignore move requests depending on the state of\n\tthe surface (e.g. fullscreen or maximized), or if the passed serial\n\tis no longer valid.\n\n\tIf triggered, the surface will lose the focus of the device\n\t(wl_pointer, wl_touch, etc) used for the move. It is up to the\n\tcompositor to visually indicate that the move is taking place, such as\n\tupdating a pointer cursor, during the move. There is no guarantee\n\tthat the device focus will return when the move is completed.","summary":"start an interactive move"},"args":[{"type":"arg","name":"seat","argType":"object","summary":"the wl_seat of the user event","interface":"wl_seat"},{"type":"arg","name":"serial","argType":"uint","summary":"the serial of the user event"}]},{"type":"request","name":"resize","description":{"type":"description","text":"Start a user-driven, interactive resize of the surface.\n\n\tThis request must be used in response to some sort of user action\n\tlike a button press, key press, or touch down event. The passed\n\tserial is used to determine the type of interactive resize (touch,\n\tpointer, etc).\n\n\tThe server may ignore resize requests depending on the state of\n\tthe surface (e.g. fullscreen or maximized).\n\n\tIf triggered, the client will receive configure events with the\n\t\"resize\" state enum value and the expected sizes. See the \"resize\"\n\tenum value for more details about what is required. The client\n\tmust also acknowledge configure events using \"ack_configure\". After\n\tthe resize is completed, the client will receive another \"configure\"\n\tevent without the resize state.\n\n\tIf triggered, the surface also will lose the focus of the device\n\t(wl_pointer, wl_touch, etc) used for the resize. It is up to the\n\tcompositor to visually indicate that the resize is taking place,\n\tsuch as updating a pointer cursor, during the resize. There is no\n\tguarantee that the device focus will return when the resize is\n\tcompleted.\n\n\tThe edges parameter specifies how the surface should be resized, and\n\tis one of the values of the resize_edge enum. Values not matching\n\ta variant of the enum will cause the invalid_resize_edge protocol error.\n\tThe compositor may use this information to update the surface position\n\tfor example when dragging the top left corner. The compositor may also\n\tuse this information to adapt its behavior, e.g. choose an appropriate\n\tcursor image.","summary":"start an interactive resize"},"args":[{"type":"arg","name":"seat","argType":"object","summary":"the wl_seat of the user event","interface":"wl_seat"},{"type":"arg","name":"serial","argType":"uint","summary":"the serial of the user event"},{"type":"arg","name":"edges","argType":"uint","summary":"which edge or corner is being dragged","enum":"resize_edge"}]},{"type":"request","name":"set_max_size","description":{"type":"description","text":"Set a maximum size for the window.\n\n\tThe client can specify a maximum size so that the compositor does\n\tnot try to configure the window beyond this size.\n\n\tThe width and height arguments are in window geometry coordinates.\n\tSee xdg_surface.set_window_geometry.\n\n\tValues set in this way are double-buffered, see wl_surface.commit.\n\n\tThe compositor can use this information to allow or disallow\n\tdifferent states like maximize or fullscreen and draw accurate\n\tanimations.\n\n\tSimilarly, a tiling window manager may use this information to\n\tplace and resize client windows in a more effective way.\n\n\tThe client should not rely on the compositor to obey the maximum\n\tsize. The compositor may decide to ignore the values set by the\n\tclient and request a larger size.\n\n\tIf never set, or a value of zero in the request, means that the\n\tclient has no expected maximum size in the given dimension.\n\tAs a result, a client wishing to reset the maximum size\n\tto an unspecified state can use zero for width and height in the\n\trequest.\n\n\tRequesting a maximum size to be smaller than the minimum size of\n\ta surface is illegal and will result in an invalid_size error.\n\n\tThe width and height must be greater than or equal to zero. Using\n\tstrictly negative values for width or height will result in a\n\tinvalid_size error.","summary":"set the maximum size"},"args":[{"type":"arg","name":"width","argType":"int"},{"type":"arg","name":"height","argType":"int"}]},{"type":"request","name":"set_min_size","description":{"type":"description","text":"Set a minimum size for the window.\n\n\tThe client can specify a minimum size so that the compositor does\n\tnot try to configure the window below this size.\n\n\tThe width and height arguments are in window geometry coordinates.\n\tSee xdg_surface.set_window_geometry.\n\n\tValues set in this way are double-buffered, see wl_surface.commit.\n\n\tThe compositor can use this information to allow or disallow\n\tdifferent states like maximize or fullscreen and draw accurate\n\tanimations.\n\n\tSimilarly, a tiling window manager may use this information to\n\tplace and resize client windows in a more effective way.\n\n\tThe client should not rely on the compositor to obey the minimum\n\tsize. The compositor may decide to ignore the values set by the\n\tclient and request a smaller size.\n\n\tIf never set, or a value of zero in the request, means that the\n\tclient has no expected minimum size in the given dimension.\n\tAs a result, a client wishing to reset the minimum size\n\tto an unspecified state can use zero for width and height in the\n\trequest.\n\n\tRequesting a minimum size to be larger than the maximum size of\n\ta surface is illegal and will result in an invalid_size error.\n\n\tThe width and height must be greater than or equal to zero. Using\n\tstrictly negative values for width and height will result in a\n\tinvalid_size error.","summary":"set the minimum size"},"args":[{"type":"arg","name":"width","argType":"int"},{"type":"arg","name":"height","argType":"int"}]},{"type":"request","name":"set_maximized","description":{"type":"description","text":"Maximize the surface.\n\n\tAfter requesting that the surface should be maximized, the compositor\n\twill respond by emitting a configure event. Whether this configure\n\tactually sets the window maximized is subject to compositor policies.\n\tThe client must then update its content, drawing in the configured\n\tstate. The client must also acknowledge the configure when committing\n\tthe new content (see ack_configure).\n\n\tIt is up to the compositor to decide how and where to maximize the\n\tsurface, for example which output and what region of the screen should\n\tbe used.\n\n\tIf the surface was already maximized, the compositor will still emit\n\ta configure event with the \"maximized\" state.\n\n\tIf the surface is in a fullscreen state, this request has no direct\n\teffect. It may alter the state the surface is returned to when\n\tunmaximized unless overridden by the compositor.","summary":"maximize the window"},"args":[]},{"type":"request","name":"unset_maximized","description":{"type":"description","text":"Unmaximize the surface.\n\n\tAfter requesting that the surface should be unmaximized, the compositor\n\twill respond by emitting a configure event. Whether this actually\n\tun-maximizes the window is subject to compositor policies.\n\tIf available and applicable, the compositor will include the window\n\tgeometry dimensions the window had prior to being maximized in the\n\tconfigure event. The client must then update its content, drawing it in\n\tthe configured state. The client must also acknowledge the configure\n\twhen committing the new content (see ack_configure).\n\n\tIt is up to the compositor to position the surface after it was\n\tunmaximized; usually the position the surface had before maximizing, if\n\tapplicable.\n\n\tIf the surface was already not maximized, the compositor will still\n\temit a configure event without the \"maximized\" state.\n\n\tIf the surface is in a fullscreen state, this request has no direct\n\teffect. It may alter the state the surface is returned to when\n\tunmaximized unless overridden by the compositor.","summary":"unmaximize the window"},"args":[]},{"type":"request","name":"set_fullscreen","description":{"type":"description","text":"Make the surface fullscreen.\n\n\tAfter requesting that the surface should be fullscreened, the\n\tcompositor will respond by emitting a configure event. Whether the\n\tclient is actually put into a fullscreen state is subject to compositor\n\tpolicies. The client must also acknowledge the configure when\n\tcommitting the new content (see ack_configure).\n\n\tThe output passed by the request indicates the client's preference as\n\tto which display it should be set fullscreen on. If this value is NULL,\n\tit's up to the compositor to choose which display will be used to map\n\tthis surface.\n\n\tIf the surface doesn't cover the whole output, the compositor will\n\tposition the surface in the center of the output and compensate with\n\twith border fill covering the rest of the output. The content of the\n\tborder fill is undefined, but should be assumed to be in some way that\n\tattempts to blend into the surrounding area (e.g. solid black).\n\n\tIf the fullscreened surface is not opaque, the compositor must make\n\tsure that other screen content not part of the same surface tree (made\n\tup of subsurfaces, popups or similarly coupled surfaces) are not\n\tvisible below the fullscreened surface.","summary":"set the window as fullscreen on an output"},"args":[{"type":"arg","name":"output","argType":"object","interface":"wl_output","allowNull":"true"}]},{"type":"request","name":"unset_fullscreen","description":{"type":"description","text":"Make the surface no longer fullscreen.\n\n\tAfter requesting that the surface should be unfullscreened, the\n\tcompositor will respond by emitting a configure event.\n\tWhether this actually removes the fullscreen state of the client is\n\tsubject to compositor policies.\n\n\tMaking a surface unfullscreen sets states for the surface based on the following:\n\t* the state(s) it may have had before becoming fullscreen\n\t* any state(s) decided by the compositor\n\t* any state(s) requested by the client while the surface was fullscreen\n\n\tThe compositor may include the previous window geometry dimensions in\n\tthe configure event, if applicable.\n\n\tThe client must also acknowledge the configure when committing the new\n\tcontent (see ack_configure).","summary":"unset the window as fullscreen"},"args":[]},{"type":"request","name":"set_minimized","description":{"type":"description","text":"Request that the compositor minimize your surface. There is no\n\tway to know if the surface is currently minimized, nor is there\n\tany way to unset minimization on this surface.\n\n\tIf you are looking to throttle redrawing when minimized, please\n\tinstead use the wl_surface.frame event for this, as this will\n\talso work with live previews on windows in Alt-Tab, Expose or\n\tsimilar compositor features.","summary":"set the window as minimized"},"args":[]}],"events":[{"type":"event","name":"configure","description":{"type":"description","text":"This configure event asks the client to resize its toplevel surface or\n\tto change its state. The configured state should not be applied\n\timmediately. See xdg_surface.configure for details.\n\n\tThe width and height arguments specify a hint to the window\n\tabout how its surface should be resized in window geometry\n\tcoordinates. See set_window_geometry.\n\n\tIf the width or height arguments are zero, it means the client\n\tshould decide its own window dimension. This may happen when the\n\tcompositor needs to configure the state of the surface but doesn't\n\thave any information about any previous or expected dimension.\n\n\tThe states listed in the event specify how the width/height\n\targuments should be interpreted, and possibly how it should be\n\tdrawn.\n\n\tClients must send an ack_configure in response to this event. See\n\txdg_surface.configure and xdg_surface.ack_configure for details.","summary":"suggest a surface change"},"args":[{"type":"arg","name":"width","argType":"int"},{"type":"arg","name":"height","argType":"int"},{"type":"arg","name":"states","argType":"array"}]},{"type":"event","name":"close","description":{"type":"description","text":"The close event is sent by the compositor when the user\n\twants the surface to be closed. This should be equivalent to\n\tthe user clicking the close button in client-side decorations,\n\tif your application has any.\n\n\tThis is only a request that the user intends to close the\n\twindow. The client may choose to ignore this request, or show\n\ta dialog to ask the user to save their data, etc.","summary":"surface wants to be closed"},"args":[]},{"type":"event","name":"configure_bounds","since":"4","description":{"type":"description","text":"The configure_bounds event may be sent prior to a xdg_toplevel.configure\n\tevent to communicate the bounds a window geometry size is recommended\n\tto constrain to.\n\n\tThe passed width and height are in surface coordinate space. If width\n\tand height are 0, it means bounds is unknown and equivalent to as if no\n\tconfigure_bounds event was ever sent for this surface.\n\n\tThe bounds can for example correspond to the size of a monitor excluding\n\tany panels or other shell components, so that a surface isn't created in\n\ta way that it cannot fit.\n\n\tThe bounds may change at any point, and in such a case, a new\n\txdg_toplevel.configure_bounds will be sent, followed by\n\txdg_toplevel.configure and xdg_surface.configure.","summary":"recommended window geometry bounds"},"args":[{"type":"arg","name":"width","argType":"int"},{"type":"arg","name":"height","argType":"int"}]},{"type":"event","name":"wm_capabilities","since":"5","description":{"type":"description","text":"This event advertises the capabilities supported by the compositor. If\n\ta capability isn't supported, clients should hide or disable the UI\n\telements that expose this functionality. For instance, if the\n\tcompositor doesn't advertise support for minimized toplevels, a button\n\ttriggering the set_minimized request should not be displayed.\n\n\tThe compositor will ignore requests it doesn't support. For instance,\n\ta compositor which doesn't advertise support for minimized will ignore\n\tset_minimized requests.\n\n\tCompositors must send this event once before the first\n\txdg_surface.configure event. When the capabilities change, compositors\n\tmust send this event again and then send an xdg_surface.configure\n\tevent.\n\n\tThe configured state should not be applied immediately. See\n\txdg_surface.configure for details.\n\n\tThe capabilities are sent as an array of 32-bit unsigned integers in\n\tnative endianness.","summary":"compositor capabilities"},"args":[{"type":"arg","name":"capabilities","argType":"array","summary":"array of 32-bit capabilities"}]}],"enums":[{"type":"enum","name":"error","bitfield":false,"entries":[{"type":"entry","name":"invalid_resize_edge","value":"0","summary":"provided value is\n        not a valid variant of the resize_edge enum"},{"type":"entry","name":"invalid_parent","value":"1","summary":"invalid parent toplevel"},{"type":"entry","name":"invalid_size","value":"2","summary":"client provided an invalid min or max size"}]},{"type":"enum","name":"resize_edge","bitfield":false,"description":{"type":"description","text":"These values are used to indicate which edge of a surface\n\tis being dragged in a resize operation.","summary":"edge values for resizing"},"entries":[{"type":"entry","name":"none","value":"0"},{"type":"entry","name":"top","value":"1"},{"type":"entry","name":"bottom","value":"2"},{"type":"entry","name":"left","value":"4"},{"type":"entry","name":"top_left","value":"5"},{"type":"entry","name":"bottom_left","value":"6"},{"type":"entry","name":"right","value":"8"},{"type":"entry","name":"top_right","value":"9"},{"type":"entry","name":"bottom_right","value":"10"}]},{"type":"enum","name":"state","bitfield":false,"description":{"type":"description","text":"The different state values used on the surface. This is designed for\n\tstate values like maximized, fullscreen. It is paired with the\n\tconfigure event to ensure that both the client and the compositor\n\tsetting the state can be synchronized.\n\n\tStates set in this way are double-buffered, see wl_surface.commit.","summary":"types of state on the surface"},"entries":[{"type":"entry","name":"maximized","value":"1","summary":"the surface is maximized","description":{"type":"description","text":"The surface is maximized. The window geometry specified in the configure\n\t  event must be obeyed by the client, or the xdg_wm_base.invalid_surface_state\n\t  error is raised.\n\n\t  The client should draw without shadow or other\n\t  decoration outside of the window geometry.","summary":"the surface is maximized"}},{"type":"entry","name":"fullscreen","value":"2","summary":"the surface is fullscreen","description":{"type":"description","text":"The surface is fullscreen. The window geometry specified in the\n\t  configure event is a maximum; the client cannot resize beyond it. For\n\t  a surface to cover the whole fullscreened area, the geometry\n\t  dimensions must be obeyed by the client. For more details, see\n\t  xdg_toplevel.set_fullscreen.","summary":"the surface is fullscreen"}},{"type":"entry","name":"resizing","value":"3","summary":"the surface is being resized","description":{"type":"description","text":"The surface is being resized. The window geometry specified in the\n\t  configure event is a maximum; the client cannot resize beyond it.\n\t  Clients that have aspect ratio or cell sizing configuration can use\n\t  a smaller size, however.","summary":"the surface is being resized"}},{"type":"entry","name":"activated","value":"4","summary":"the surface is now activated","description":{"type":"description","text":"Client window decorations should be painted as if the window is\n\t  active. Do not assume this means that the window actually has\n\t  keyboard or pointer focus.","summary":"the surface is now activated"}},{"type":"entry","name":"tiled_left","value":"5","since":"2","description":{"type":"description","text":"The window is currently in a tiled layout and the left edge is\n\t  considered to be adjacent to another part of the tiling grid.\n\n\t  The client should draw without shadow or other decoration outside of\n\t  the window geometry on the left edge.","summary":"the surface’s left edge is tiled"}},{"type":"entry","name":"tiled_right","value":"6","since":"2","description":{"type":"description","text":"The window is currently in a tiled layout and the right edge is\n\t  considered to be adjacent to another part of the tiling grid.\n\n\t  The client should draw without shadow or other decoration outside of\n\t  the window geometry on the right edge.","summary":"the surface’s right edge is tiled"}},{"type":"entry","name":"tiled_top","value":"7","since":"2","description":{"type":"description","text":"The window is currently in a tiled layout and the top edge is\n\t  considered to be adjacent to another part of the tiling grid.\n\n\t  The client should draw without shadow or other decoration outside of\n\t  the window geometry on the top edge.","summary":"the surface’s top edge is tiled"}},{"type":"entry","name":"tiled_bottom","value":"8","since":"2","description":{"type":"description","text":"The window is currently in a tiled layout and the bottom edge is\n\t  considered to be adjacent to another part of the tiling grid.\n\n\t  The client should draw without shadow or other decoration outside of\n\t  the window geometry on the bottom edge.","summary":"the surface’s bottom edge is tiled"}},{"type":"entry","name":"suspended","value":"9","since":"6","description":{"type":"description","text":"The surface is currently not ordinarily being repainted; for\n\t  example because its content is occluded by another window, or its\n\t  outputs are switched off due to screen locking.","summary":"surface repaint is suspended"}}]},{"type":"enum","name":"wm_capabilities","since":"5","bitfield":false,"entries":[{"type":"entry","name":"window_menu","value":"1","summary":"show_window_menu is available"},{"type":"entry","name":"maximize","value":"2","summary":"set_maximized and unset_maximized are available"},{"type":"entry","name":"fullscreen","value":"3","summary":"set_fullscreen and unset_fullscreen are available"},{"type":"entry","name":"minimize","value":"4","summary":"set_minimized is available"}]}]},{"type":"interface","name":"xdg_popup","version":"6","description":{"type":"description","text":"A popup surface is a short-lived, temporary surface. It can be used to\n      implement for example menus, popovers, tooltips and other similar user\n      interface concepts.\n\n      A popup can be made to take an explicit grab. See xdg_popup.grab for\n      details.\n\n      When the popup is dismissed, a popup_done event will be sent out, and at\n      the same time the surface will be unmapped. See the xdg_popup.popup_done\n      event for details.\n\n      Explicitly destroying the xdg_popup object will also dismiss the popup and\n      unmap the surface. Clients that want to dismiss the popup when another\n      surface of their own is clicked should dismiss the popup using the destroy\n      request.\n\n      A newly created xdg_popup will be stacked on top of all previously created\n      xdg_popup surfaces associated with the same xdg_toplevel.\n\n      The parent of an xdg_popup must be mapped (see the xdg_surface\n      description) before the xdg_popup itself.\n\n      The client must call wl_surface.commit on the corresponding wl_surface\n      for the xdg_popup state to take effect.","summary":"short-lived, popup surfaces for menus"},"requests":[{"type":"request","name":"destroy","requestType":"destructor","description":{"type":"description","text":"This destroys the popup. Explicitly destroying the xdg_popup\n\tobject will also dismiss the popup, and unmap the surface.\n\n\tIf this xdg_popup is not the \"topmost\" popup, the\n\txdg_wm_base.not_the_topmost_popup protocol error will be sent.","summary":"remove xdg_popup interface"},"args":[]},{"type":"request","name":"grab","description":{"type":"description","text":"This request makes the created popup take an explicit grab. An explicit\n\tgrab will be dismissed when the user dismisses the popup, or when the\n\tclient destroys the xdg_popup. This can be done by the user clicking\n\toutside the surface, using the keyboard, or even locking the screen\n\tthrough closing the lid or a timeout.\n\n\tIf the compositor denies the grab, the popup will be immediately\n\tdismissed.\n\n\tThis request must be used in response to some sort of user action like a\n\tbutton press, key press, or touch down event. The serial number of the\n\tevent should be passed as 'serial'.\n\n\tThe parent of a grabbing popup must either be an xdg_toplevel surface or\n\tanother xdg_popup with an explicit grab. If the parent is another\n\txdg_popup it means that the popups are nested, with this popup now being\n\tthe topmost popup.\n\n\tNested popups must be destroyed in the reverse order they were created\n\tin, e.g. the only popup you are allowed to destroy at all times is the\n\ttopmost one.\n\n\tWhen compositors choose to dismiss a popup, they may dismiss every\n\tnested grabbing popup as well. When a compositor dismisses popups, it\n\twill follow the same dismissing order as required from the client.\n\n\tIf the topmost grabbing popup is destroyed, the grab will be returned to\n\tthe parent of the popup, if that parent previously had an explicit grab.\n\n\tIf the parent is a grabbing popup which has already been dismissed, this\n\tpopup will be immediately dismissed. If the parent is a popup that did\n\tnot take an explicit grab, an error will be raised.\n\n\tDuring a popup grab, the client owning the grab will receive pointer\n\tand touch events for all their surfaces as normal (similar to an\n\t\"owner-events\" grab in X11 parlance), while the top most grabbing popup\n\twill always have keyboard focus.","summary":"make the popup take an explicit grab"},"args":[{"type":"arg","name":"seat","argType":"object","summary":"the wl_seat of the user event","interface":"wl_seat"},{"type":"arg","name":"serial","argType":"uint","summary":"the serial of the user event"}]},{"type":"request","name":"reposition","since":"3","description":{"type":"description","text":"Reposition an already-mapped popup. The popup will be placed given the\n\tdetails in the passed xdg_positioner object, and a\n\txdg_popup.repositioned followed by xdg_popup.configure and\n\txdg_surface.configure will be emitted in response. Any parameters set\n\tby the previous positioner will be discarded.\n\n\tThe passed token will be sent in the corresponding\n\txdg_popup.repositioned event. The new popup position will not take\n\teffect until the corresponding configure event is acknowledged by the\n\tclient. See xdg_popup.repositioned for details. The token itself is\n\topaque, and has no other special meaning.\n\n\tIf multiple reposition requests are sent, the compositor may skip all\n\tbut the last one.\n\n\tIf the popup is repositioned in response to a configure event for its\n\tparent, the client should send an xdg_positioner.set_parent_configure\n\tand possibly an xdg_positioner.set_parent_size request to allow the\n\tcompositor to properly constrain the popup.\n\n\tIf the popup is repositioned together with a parent that is being\n\tresized, but not in response to a configure event, the client should\n\tsend an xdg_positioner.set_parent_size request.","summary":"recalculate the popup's location"},"args":[{"type":"arg","name":"positioner","argType":"object","interface":"xdg_positioner"},{"type":"arg","name":"token","argType":"uint","summary":"reposition request token"}]}],"events":[{"type":"event","name":"configure","description":{"type":"description","text":"This event asks the popup surface to configure itself given the\n\tconfiguration. The configured state should not be applied immediately.\n\tSee xdg_surface.configure for details.\n\n\tThe x and y arguments represent the position the popup was placed at\n\tgiven the xdg_positioner rule, relative to the upper left corner of the\n\twindow geometry of the parent surface.\n\n\tFor version 2 or older, the configure event for an xdg_popup is only\n\tever sent once for the initial configuration. Starting with version 3,\n\tit may be sent again if the popup is setup with an xdg_positioner with\n\tset_reactive requested, or in response to xdg_popup.reposition requests.","summary":"configure the popup surface"},"args":[{"type":"arg","name":"x","argType":"int","summary":"x position relative to parent surface window geometry"},{"type":"arg","name":"y","argType":"int","summary":"y position relative to parent surface window geometry"},{"type":"arg","name":"width","argType":"int","summary":"window geometry width"},{"type":"arg","name":"height","argType":"int","summary":"window geometry height"}]},{"type":"event","name":"popup_done","description":{"type":"description","text":"The popup_done event is sent out when a popup is dismissed by the\n\tcompositor. The client should destroy the xdg_popup object at this\n\tpoint.","summary":"popup interaction is done"},"args":[]},{"type":"event","name":"repositioned","since":"3","description":{"type":"description","text":"The repositioned event is sent as part of a popup configuration\n\tsequence, together with xdg_popup.configure and lastly\n\txdg_surface.configure to notify the completion of a reposition request.\n\n\tThe repositioned event is to notify about the completion of a\n\txdg_popup.reposition request. The token argument is the token passed\n\tin the xdg_popup.reposition request.\n\n\tImmediately after this event is emitted, xdg_popup.configure and\n\txdg_surface.configure will be sent with the updated size and position,\n\tas well as a new configure serial.\n\n\tThe client should optionally update the content of the popup, but must\n\tacknowledge the new popup configuration for the new position to take\n\teffect. See xdg_surface.ack_configure for details.","summary":"signal the completion of a repositioned request"},"args":[{"type":"arg","name":"token","argType":"uint","summary":"reposition request token"}]}],"enums":[{"type":"enum","name":"error","bitfield":false,"entries":[{"type":"entry","name":"invalid_grab","value":"0","summary":"tried to grab after being mapped"}]}]}]}