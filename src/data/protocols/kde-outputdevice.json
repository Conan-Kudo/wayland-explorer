{"type":"protocol","name":"org_kde_kwin_outputdevice","copyright":{"type":"copyright","text":"\n        SPDX-FileCopyrightText: 2008-2011 Kristian Høgsberg\n        SPDX-FileCopyrightText: 2010-2011 Intel Corporation\n        SPDX-FileCopyrightText: 2012-2013 Collabora, Ltd.\n        SPDX-FileCopyrightText: 2015 Sebastian Kügler <sebas@kde.org>\n\n        SPDX-License-Identifier: MIT-CMU\n        "},"interfaces":[{"type":"interface","name":"org_kde_kwin_outputdevice","version":"4","description":{"type":"description","text":"An outputdevice describes a display device available to the compositor.\n        outputdevice is similar to wl_output, but focuses on output\n        configuration management.\n\n        A client can query all global outputdevice objects to enlist all\n        available display devices, even those that may currently not be\n        represented by the compositor as a wl_output.\n\n        The client sends configuration changes to the server through the\n        outputconfiguration interface, and the server applies the configuration\n        changes to the hardware and signals changes to the outputdevices\n        accordingly.\n\n        This object is published as global during start up for every available\n        display devices, or when one later becomes available, for example by\n        being hotplugged via a physical connector.","summary":"output configuration representation"},"requests":[],"events":[{"type":"event","name":"geometry","description":{"type":"description","text":"The geometry event describes geometric properties of the output.\n            The event is sent when binding to the output object and whenever\n            any of the properties change.","summary":"geometric properties of the output"},"args":[{"type":"arg","name":"x","argType":"int","summary":"x position within the global compositor space"},{"type":"arg","name":"y","argType":"int","summary":"y position within the global compositor space"},{"type":"arg","name":"physical_width","argType":"int","summary":"width in millimeters of the output"},{"type":"arg","name":"physical_height","argType":"int","summary":"height in millimeters of the output"},{"type":"arg","name":"subpixel","argType":"int","summary":"subpixel orientation of the output"},{"type":"arg","name":"make","argType":"string","summary":"textual description of the manufacturer"},{"type":"arg","name":"model","argType":"string","summary":"textual description of the model"},{"type":"arg","name":"transform","argType":"int","summary":"transform that maps framebuffer to output"}]},{"type":"event","name":"mode","description":{"type":"description","text":"The mode event describes an available mode for the output.\n\n            When the client binds to the outputdevice object, the server sends this\n            event once for every available mode the outputdevice can be operated by.\n\n            There will always be at least one event sent out on initial binding,\n            which represents the current mode.\n\n            Later on if an output changes its mode the event is sent again, whereby\n            this event represents the mode that has now become current. In other\n            words, the current mode is always represented by the latest event sent\n            with the current flag set.\n\n            The size of a mode is given in physical hardware units of the output device.\n            This is not necessarily the same as the output size in the global compositor\n            space. For instance, the output may be scaled, as described in\n            org_kde_kwin_outputdevice.scale, or transformed, as described in\n            org_kde_kwin_outputdevice.transform.\n\n            The id can be used to refer to a mode when calling set_mode on an\n            org_kde_kwin_outputconfiguration object.","summary":"advertise available output modes and current one"},"args":[{"type":"arg","name":"flags","argType":"uint","summary":"bitfield of mode flags"},{"type":"arg","name":"width","argType":"int","summary":"width of the mode in hardware units"},{"type":"arg","name":"height","argType":"int","summary":"height of the mode in hardware units"},{"type":"arg","name":"refresh","argType":"int","summary":"vertical refresh rate in mHz"},{"type":"arg","name":"mode_id","argType":"int","summary":"Per outputdevice unique id to identify a mode"}]},{"type":"event","name":"done","description":{"type":"description","text":"This event is sent after all other properties have been\n            sent on binding to the output object as well as after any\n            other output property change have been applied later on.\n            This allows to see changes to the output properties as atomic,\n            even if multiple events successively announce them.","summary":"sent all information about output"},"args":[]},{"type":"event","name":"scale","description":{"type":"description","text":"This event contains scaling geometry information\n            that is not in the geometry event. It may be sent after\n            binding the output object or if the output scale changes\n            later. If it is not sent, the client should assume a\n            scale of 1.\n\n            A scale larger than 1 means that the compositor will\n            automatically scale surface buffers by this amount\n            when rendering. This is used for high resolution\n            displays where applications rendering at the native\n            resolution would be too small to be legible.\n\n            It is intended that scaling aware clients track the\n            current output of a surface, and if it is on a scaled\n            output it should use wl_surface.set_buffer_scale with\n            the scale of the output. That way the compositor can\n            avoid scaling the surface, and the client can supply\n            a higher detail image.","summary":"output scaling properties"},"args":[{"type":"arg","name":"factor","argType":"int","summary":"scaling factor of output"}]},{"type":"event","name":"edid","description":{"type":"description","text":"The edid event encapsulates the EDID data for the outputdevice.\n\n            The event is sent when binding to the output object. The EDID\n            data may be empty, in which case this event is sent anyway.\n            If the EDID information is empty, you can fall back to the name\n            et al. properties of the outputdevice.","summary":"advertise EDID data for the output"},"args":[{"type":"arg","name":"raw","argType":"string","summary":"base64-encoded EDID string"}]},{"type":"event","name":"enabled","description":{"type":"description","text":"The enabled event notifies whether this output is currently\n            enabled and used for displaying content by the server.\n            The event is sent when binding to the output object and\n            whenever later on an output changes its state by becoming\n            enabled or disabled.","summary":"output is enabled or disabled"},"args":[{"type":"arg","name":"enabled","argType":"int","summary":"output enabled state"}]},{"type":"event","name":"uuid","description":{"type":"description","text":"The uuid can be used to identify the output. It's controlled by\n            the server entirely. The server should make sure the uuid is\n            persistent across restarts. An empty uuid is considered invalid.","summary":"A unique id for this outputdevice"},"args":[{"type":"arg","name":"uuid","argType":"string","summary":"output devices ID"}]},{"type":"event","name":"scalef","since":"2","description":{"type":"description","text":"This event contains scaling geometry information\n            that is not in the geometry event. It may be sent after\n            binding the output object or if the output scale changes\n            later. If it is not sent, the client should assume a\n            scale of 1.\n\n            A scale larger than 1 means that the compositor will\n            automatically scale surface buffers by this amount\n            when rendering. This is used for high resolution\n            displays where applications rendering at the native\n            resolution would be too small to be legible.\n\n            It is intended that scaling aware clients track the\n            current output of a surface, and if it is on a scaled\n            output it should use wl_surface.set_buffer_scale with\n            the scale of the output. That way the compositor can\n            avoid scaling the surface, and the client can supply\n            a higher detail image.\n\n            wl_output will keep the output scale as an integer. In every situation except\n            configuring the window manager you want to use that.","summary":"output scaling properties"},"args":[{"type":"arg","name":"factor","argType":"fixed","summary":"scaling factor of output"}]},{"type":"event","name":"colorcurves","since":"2","description":{"type":"description","text":"Describes the color intensity profile of the output.\n            Commonly used for gamma/color correction.\n\n            The array contains all color ramp values of the output.\n            For example on 8bit screens there are 256 of them.\n\n            The array elements are unsigned 16bit integers.","summary":"output color curves"},"args":[{"type":"arg","name":"red","argType":"array","summary":"red color ramp"},{"type":"arg","name":"green","argType":"array","summary":"green color ramp"},{"type":"arg","name":"blue","argType":"array","summary":"blue color ramp"}]},{"type":"event","name":"serial_number","since":"2","description":{"type":"description","text":"Serial ID of the monitor, sent on startup before the first done event.","summary":"Serial Number"},"args":[{"type":"arg","name":"serialNumber","argType":"string","summary":"textual representation of serial number"}]},{"type":"event","name":"eisa_id","since":"2","description":{"type":"description","text":"EISA ID of the monitor, sent on startup before the first done event.","summary":"EISA ID"},"args":[{"type":"arg","name":"eisaId","argType":"string","summary":"textual representation of EISA identifier"}]},{"type":"event","name":"capabilities","since":"3","description":{"type":"description","text":"What capabilities this device has, sent on startup before the first\n            done event.","summary":"capability flags"},"args":[{"type":"arg","name":"flags","argType":"uint","enum":"capability"}]},{"type":"event","name":"overscan","since":"3","description":{"type":"description","text":"Overscan value of the monitor in percent, sent on startup before the\n            first done event.","summary":"overscan"},"args":[{"type":"arg","name":"overscan","argType":"uint","summary":"amount of overscan of the monitor"}]},{"type":"event","name":"vrr_policy","since":"4","description":{"type":"description","text":"What policy the compositor will employ regarding its use of variable\n            refresh rate.","summary":"Variable Refresh Rate Policy"},"args":[{"type":"arg","name":"vrr_policy","argType":"uint","enum":"vrr_policy"}]}],"enums":[{"type":"enum","name":"subpixel","bitfield":false,"description":{"type":"description","text":"This enumeration describes how the physical pixels on an output are\n            laid out.","summary":"subpixel geometry information"},"entries":[{"type":"entry","name":"unknown","value":"0"},{"type":"entry","name":"none","value":"1"},{"type":"entry","name":"horizontal_rgb","value":"2"},{"type":"entry","name":"horizontal_bgr","value":"3"},{"type":"entry","name":"vertical_rgb","value":"4"},{"type":"entry","name":"vertical_bgr","value":"5"}]},{"type":"enum","name":"transform","bitfield":false,"description":{"type":"description","text":"This describes the transform, that a compositor will apply to a\n            surface to compensate for the rotation or mirroring of an\n            output device.\n\n            The flipped values correspond to an initial flip around a\n            vertical axis followed by rotation.\n\n            The purpose is mainly to allow clients to render accordingly and\n            tell the compositor, so that for fullscreen surfaces, the\n            compositor is still able to scan out directly client surfaces.","summary":"transform from framebuffer to output"},"entries":[{"type":"entry","name":"normal","value":"0"},{"type":"entry","name":"90","value":"1"},{"type":"entry","name":"180","value":"2"},{"type":"entry","name":"270","value":"3"},{"type":"entry","name":"flipped","value":"4"},{"type":"entry","name":"flipped_90","value":"5"},{"type":"entry","name":"flipped_180","value":"6"},{"type":"entry","name":"flipped_270","value":"7"}]},{"type":"enum","name":"mode","bitfield":false,"description":{"type":"description","text":"These flags describe properties of an output mode. They are\n            used in the flags bitfield of the mode event.","summary":"mode information"},"entries":[{"type":"entry","name":"current","value":"0x1","summary":"indicates this is the current mode"},{"type":"entry","name":"preferred","value":"0x2","summary":"indicates this is the preferred mode"}]},{"type":"enum","name":"enablement","bitfield":false,"description":{"type":"description","text":"Describes whether a device is enabled, i.e. device is used to\n            display content by the compositor. This wraps a boolean around\n            an int to avoid a boolean trap.","summary":"describes enabled state"},"entries":[{"type":"entry","name":"disabled","value":"0"},{"type":"entry","name":"enabled","value":"1"}]},{"type":"enum","name":"capability","since":"3","bitfield":true,"description":{"type":"description","text":"Describes what capabilities this device has.","summary":"describes capabilities of the outputdevice"},"entries":[{"type":"entry","name":"overscan","value":"1","summary":"if this outputdevice can use overscan"},{"type":"entry","name":"vrr","value":"2","summary":"if this outputdevice supports variable refresh rate","since":"4"}]},{"type":"enum","name":"vrr_policy","since":"4","bitfield":false,"description":{"type":"description","text":"Describes when the compositor may employ variable refresh rate","summary":"describes vrr policy"},"entries":[{"type":"entry","name":"never","value":"0"},{"type":"entry","name":"always","value":"1"},{"type":"entry","name":"automatic","value":"2"}]}]}]}